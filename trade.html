<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Trade Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <base href="./" />
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root{--muted:#9ca3af;--bd:#2f2f2f}
    body{margin:0;background:#0b1320;color:#e5e7eb;font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 16px;position:sticky;top:0;background:#0b1320;z-index:1}
    .pill{padding:.45rem .75rem;border:1px solid var(--bd);border-radius:.75rem;color:#d1d5db;text-decoration:none}
    .pill:hover{background:#111827}
    .muted{color:var(--muted)}
    main{padding:12px 16px}
    #log{white-space:pre-wrap;margin:0 16px 8px 16px;color:#f59e0b}
    .card{border:1px solid var(--bd);border-radius:.75rem;padding:12px;margin:12px 0}
    .row{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:12px;flex-wrap:wrap}
    .party{border:1px solid var(--bd);border-radius:.65rem;padding:10px;margin:8px 0}
    .grade{display:flex;align-items:center;gap:8px;margin-top:8px}
    .bar{height:6px;border-radius:4px;background:#0f172a;overflow:hidden;flex:1;min-width:120px}
    .bar>span{display:block;height:100%}
    #q{min-width:260px}
    .legend{font-size:.85rem;margin:6px 16px 0 16px}
    .mini{font-size:.85rem}
  </style>
</head>
<body>
  <header>
    <a class="pill" href="index.html">← Back</a>
    <h1 style="margin:0;font-size:1.25rem">Trade Analysis</h1>
    <input id="q" type="search" placeholder="Search player/team…" aria-label="Search" />
  </header>

  <div id="log" class="muted"></div>
  <div id="meta" class="muted" style="margin:0 16px 8px 16px;"></div>
  <div class="legend muted">
    Grade = clamp(50 + <span class="mini">S</span> × (Actual Δ + <span class="mini">W</span> × ROS Δ)). Defaults: <span class="mini">S</span>=0.18, <span class="mini">W</span>=0.65.
    Actual Δ = started pts since trade (team). ROS Δ = Sleeper projections for remaining weeks.
  </div>
  <main id="list"></main>

  <script>
  (async function(){
    // ---------------- Tunables ----------------
    const SCALE_S = 0.18;     // sensitivity → grade (higher = harsher spread)
    const ROS_WEIGHT = 0.65;  // weight for rest-of-season vs actual so far
    const REG_SEASON_WEEKS = 18; // NFL regular season length

    // --------------- DOM helpers --------------
    const log = document.getElementById('log');
    const meta = document.getElementById('meta');
    const list = document.getElementById('list');
    const q = document.getElementById('q');
    function el(t,a={},...kids){const n=document.createElement(t);
      for(const[k,v] of Object.entries(a))(k==='class')?n.className=v:n.setAttribute(k,v);
      for(const k of kids)n.append(k?.nodeType?k:document.createTextNode(String(k??"")));
      return n;
    }
    const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
    const colorFor = g => g>=70?'#22c55e': g>=60?'#84cc16': g>=50?'#f59e0b':'#ef4444';

    // --------------- Data fetchers ------------
    const TRADES_URL  = new URL('data/trades-2025.json', location.href).toString();
    const SEASON_URL  = new URL('data/2025.json',        location.href).toString();
    const stateUrl    = 'https://api.sleeper.app/v1/state/nfl';
    const projUrl     = (year,week)=>`https://api.sleeper.app/projections/nfl/regular/${year}/${week}`;

    async function fetchJSON(url){
      const r = await fetch(url + (url.includes('?')?'&':'?') + 'v=' + Date.now(), {cache:'no-store'});
      if(!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
      return r.json();
    }

    // --------------- Lineups index ------------
    // team -> playerName -> Map(week -> startedPoints)
    function indexLineups(lineups){
      const byTeam = new Map();
      for(const r of (lineups||[])){
        if(!r?.started) continue;
        const team = String(r.team||'').trim(); if(!team) continue;
        const player = String(r.player||'').trim(); if(!player) continue;
        const wk = Number(r.week||0); const pts = Number(r.points||0);
        if(!byTeam.has(team)) byTeam.set(team, new Map());
        const tm = byTeam.get(team);
        if(!tm.has(player)) tm.set(player, new Map());
        tm.get(player).set(wk, (tm.get(player).get(wk)||0)+pts);
      }
      return byTeam;
    }
    function sumStartedAfterWeek(teamName, playerNames, week, index){
      const tm = index.get(teamName); if(!tm) return 0;
      let s=0;
      for(const name of playerNames){
        const weeks = tm.get(name); if(!weeks) continue;
        for(const [wk, pts] of weeks.entries()){
          if(Number(wk) > Number(week)) s += Number(pts||0);
        }
      }
      return s;
    }

    // --------------- Projections cache --------
    const PROJ_CACHE = new Map(); // week -> Map(player_id -> proj)
    let currentSleeperSeason = 2025;
    let currentWeek = 1;

    async function ensureWeekProjections(week){
      if(PROJ_CACHE.has(week)) return PROJ_CACHE.get(week);
      try{
        const r = await fetch(projUrl(currentSleeperSeason, week), {cache:'no-store'});
        if(!r.ok) throw new Error('proj http '+r.status);
        const arr = await r.json();
        const m = new Map();
        for(const row of arr||[]){
          const pid = String(row.player_id || row.player?.player_id || row.id || '');
          const proj = Number(row.fp ?? row.fpts ?? row.proj ?? row.points ?? 0);
          if(pid) m.set(pid, proj);
        }
        PROJ_CACHE.set(week, m);
        return m;
      }catch(e){
        // cache empty map to avoid refetch storms
        const m = new Map(); PROJ_CACHE.set(week, m); return m;
      }
    }
    async function sumProjected(playerIds, startWeekExclusive){
      if(!playerIds?.length) return 0;
      let sum = 0;
      for(let w = Math.max(startWeekExclusive+1, currentWeek); w <= REG_SEASON_WEEKS; w++){
        const m = await ensureWeekProjections(w);
        for(const pid of playerIds){
          sum += Number(m.get(String(pid)) || 0);
        }
      }
      return sum;
    }

    // --------------- Grade calc ----------------
    function names(list){ return (list||[]).map(x=>String(x?.name||'').trim()).filter(Boolean); }
    function ids(list){ return (list||[]).map(x=>String(x?.id||'')).filter(Boolean); }

    async function gradeParty(party, tradeWeek, lineupIndex){
      // Actual delta: points started for this team after trade week
      const gotNames  = names(party.gained_players);
      const sentNames = names(party.sent_players);
      const actualGot  = sumStartedAfterWeek(party.team, gotNames,  tradeWeek, lineupIndex);
      const actualSent = sumStartedAfterWeek(party.team, sentNames, tradeWeek, lineupIndex);
      const actualDelta = actualGot - actualSent;

      // ROS delta: projections for remaining weeks (use player IDs)
      const gotIds  = ids(party.gained_players);
      const sentIds = ids(party.sent_players);
      const rosGot  = await sumProjected(gotIds,  tradeWeek);
      const rosSent = await sumProjected(sentIds, tradeWeek);
      const rosDelta = rosGot - rosSent;

      const combined = actualDelta + ROS_WEIGHT*rosDelta;
      const grade = clamp(50 + SCALE_S*combined, 0, 100);
      return { actualDelta, rosDelta, combined, grade };
    }

    // --------------- UI -----------------------
    function partyBlock(p, metrics){
      const got  = (p.gained_players||[]).map(x=>x.name);
      const sent = (p.sent_players||[]).map(x=>x.name);
      const gotP = (p.gained_picks||[]).map(x=>`Pick ${x.season??""} R${x.round??""}`);
      const senP = (p.sent_picks||[]).map(x=>`Pick ${x.season??""} R${x.round??""}`);

      const g = metrics?.grade ?? null;
      const pct = g==null ? 0 : clamp(g, 4, 100);
      const bar  = el('div',{class:'bar'}, el('span',{style:`width:${pct}%;background:${colorFor(g||50)}`}));

      return el('div',{class:'party'},
        el('div',{style:'font-weight:700;margin-bottom:6px'}, p.team || `Roster ${p.roster_id||""}`),
        el('div',{}, el('span',{class:'muted'},'Received: '), (got.length||gotP.length)? [...got,...gotP].join(', ') : '—'),
        el('div',{}, el('span',{class:'muted'},'Sent: '),     (sent.length||senP.length)? [...sent,...senP].join(', ') : '—'),
        el('div',{class:'grade'},
          el('span',{class:'muted'},
            metrics
              ? `Actual Δ ${metrics.actualDelta.toFixed(1)}  •  ROS Δ ${metrics.rosDelta.toFixed(1)}  •  Grade ${metrics.grade.toFixed(0)}`
              : 'Scoring…'
          ),
          bar
        )
      );
    }

    function draw(trades, lineupIndex){
      const needle = (q.value||'').trim().toLowerCase();
      list.innerHTML = '';
      let shown = 0;
      for(const t of trades){
        const hay = (t.parties||[]).map(p => [
          p.team,
          ...(p.gained_players||[]).map(x=>x.name),
          ...(p.sent_players||[]).map(x=>x.name)
        ].join(' ')).join(' ').toLowerCase();
        if (needle && !hay.includes(needle)) continue;

        const header = (t.parties||[]).map(p=>p.team).filter(Boolean).join(' ↔ ');
        const card = el('section',{class:'card', 'data-week': String(t.week||'')},
          el('div',{class:'row'},
            el('strong',{}, `Week ${t.week ?? '—'}`),
            el('span',{class:'muted'}, header)
          )
        );

        // initial placeholders
        const blocks = (t.parties||[]).map(p=>{
          const ph = partyBlock(p, null);
          card.appendChild(ph);
          return { party:p, node:ph };
        });

        // async compute and update
        (async ()=>{
          for(const b of blocks){
            const m = await gradeParty(b.party, Number(t.week||0), lineupIndex);
            const updated = partyBlock(b.party, m);
            b.node.replaceWith(updated);
          }
        })();

        list.appendChild(card);
        shown++;
      }
      if (shown===0) list.appendChild(el('div',{class:'card muted'}, 'No trades match your filter.'));
    }

    // --------------- Boot ---------------------
    try{
      log.textContent = 'Loading…';
      const [tradesData, seasonData, nflState] = await Promise.allSettled([
        fetchJSON(TRADES_URL),
        fetchJSON(SEASON_URL),
        fetchJSON(stateUrl)
      ]);

      if(tradesData.status!=='fulfilled') throw tradesData.reason;
      const data = tradesData.value;
      const trades = (data.trades||[]).slice().sort((a,b)=>(a.week??0)-(b.week??0)||(a.created??0)-(b.created??0));
      meta.textContent = `${trades.length} trades • Season ${data.year ?? 2025}`;

      // lineups index (actual started points)
      let lineupIndex = new Map();
      if(seasonData.status==='fulfilled' && Array.isArray(seasonData.value?.lineups)){
        lineupIndex = indexLineups(seasonData.value.lineups);
      }

      // Sleeper state (season/week)
      if(nflState.status==='fulfilled'){
        currentSleeperSeason = Number(nflState.value?.season || 2025);
        currentWeek = Number(nflState.value?.week || 1);
      } else {
        currentSleeperSeason = 2025; currentWeek = 1;
      }

      log.textContent = `Using Sleeper season ${currentSleeperSeason}, current week ${currentWeek}. Trades: ${trades.length}.`;
      draw(trades, lineupIndex);
      q.oninput = () => draw(trades, lineupIndex);
    }catch(e){
      log.textContent = `Load error: ${String(e && e.message || e)}`;
      console.error(e);
    }
  })();
  </script>
</body>
</html>
